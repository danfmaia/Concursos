# BACEN - Disciplina 8 - Engenharia de Software (ES)

Prof. Tiago Lage Payne de Pádua

# 8.1 - Arquitetura de Sistemas Web

## Conhecimentos prévios

- Protocolo TPC - ???[TODO]

  > ???[TODO]

- Modelo OSI

  > _Modelo da camada de aplicação_ predominante.

  > Def. — O modelo OSI (Open Systems Interconnection) é um modelo de referência que _descreve como os dispositivos de rede se comunicam entre si_.

  > Ele é _dividido em sete camadas_: física, de enlace, de rede, de transporte, de sessão, de apresentação e de aplicação.

  > Cada camada possui funções específicas e trabalha em conjunto para garantir a _comunicação eficiente e confiável entre os dispositivos de rede_.

  > O modelo OSI é amplamente utilizado na área de redes de computadores para _facilitar o desenvolvimento, a implementação e a manutenção de sistemas de comunicação_.

## 8.1.1 - Protocolo HTTP

- Def. — Hypertext Transfer Protocol (HTTP) é um _protocolo de camada de aplicação p/ transmissão de documentos hipermídia_, como o HTML.

- Outros protocolos:

  - FTP - File Transfer Protocol
    > Transferência de arquivos. Pouco utilizado atualmente.
  - SMTP - Simple Mail Transfer Protocol
    > Correio eletrônico.
  - NSF - Network File System
    > Servidor remoto de arquivos.
  - SSH - Secure Shell
    > Acesso a terminal remoto.
  - Telnet
    > Acesso a terminal remoto. Muito pouco utilizado atualmente.

- Foi desenvolvido p/ _comunicação entre navevagores web e servidores web_, porém tbm pode ser utilizado p/ _outros propósitos_.

- Segue um _modelo cliente-servidor clássico_, onde um cliente abre uma conexão, executa uma requisição e espera até receber uma resposta.

- É tbm um protocolo _sem estado (stateless)_, que significa que o servidor não mantém nenhum dado entre duas requisições (state).

### Portas padrões de protocolos

- HTTP: 80
- HTTPS: 443
- SSH: 22
- DNS: 53

### Componentes de sistemas baseados em HTTP

- O HTTP é um protocolo **cliente-servidor**: as requisições são enviadas por uma _entidade_, o agente-usuário (ou um proxy em nome dele).

- A maior parte do tempo, o agente-usuário é um navegador da web, mas pode ser qualquer coisa, como por exemplo um robô que varre a web p/ preencher e manter um índice de mecanismo de pesquisa e coletar informações.

- Cada _requisição (request)_ individual é enviada p/ um servidor, que irá lidar com isso e fornecer um resultado, chamado de _resposta (response)_.

- Entre a requisição e a resposta existem várias entidades, designadas coletivamente como _proxies_, que executam operações diferentes e atuam como gateways (intermediários) ou caches, por exemplo.

### Cliente: o agente-usuário

- Def. — O agente-usuário é qualquer ferramenta que _age em nome do usuário_.

- Essa função é predominantemente realizada pelo navegador web.

- O agente-usuário _sempre é a entidade que inicia as requisições_, nunca o lado do servidor.
  > Embora alguns mecanismos tenham sido adicionados ao longo dos anos p/ simular mensagens iniciadas pelo servidor.

### Servidor (web)

- Do outro lado do canal de comunicação está o servidor, que serve o documento requisitado pelo usuário.

- Um servidor se apresenta virtualmente como uma única máquina.
  > Isto porque o servidor pode ser uma _coleção de servidores dividindo a carga_—através de uma técnica chamada _balanceamento de carga (load balancer)_—ou também como um programa complexo que _acessa outros servidores_ (como um cache, um servidor de banco de dados, servidores e-commerce, etc), gerando todo ou parte do documento solicitado.

### Proxies

- Entre o navegador web e o servidor, _vários computadores e máquinas transmitem as mensagens HTTP_.

- Devido a estrutura em camadas da pilha web, _a maioria dessas máquinas operam em alguma das camadas_ (de transporte, de rede ou física), sendo _transparentes_ na camada da aplicação HTTP, e potencialmente exercendo um grande impacto na performance.

- Essas _máquinas que operam na camada de aplicação são normalmente conhecidas como proxies_ (ou representantes, ou procuradores).

### Aspectos básicos do HTTP

- Simples.
- Extensível.
  > Cabeçalhos (headers).
- Não tem estado, mas tem sessões.
  > Cookies.
- HTTP e conexões.
  > O HTTP utiliza apenas o protocolo de conexão TCP, por ser um protocolo confiável. Há tbm o protocolo UDP, que não é confiável e possui casos de uso diferentes.

### O que pode ser controlado pelo HTTP

- Cache
- Relaxamento das restrições na origem
- Autenticação
  > Basic Authentication. Não é recomendado.
- Proxy e tunelamento
- Sessões
  > Cookies.

### Fluxo HTTP

1. Abre uma conexão TCP.

   > A conexão TCP será usada p/ enviar uma requisição, ou várias, e receber uma resposta. O cliente pode abrir uma nova conexão, reusar uma conexão existente, ou abrir várias conexões ao servidores.

2. Envia uma mensagem HTTP.

   > Mensagens HTTP antes do HTTP/2.0 são legíveis às pessoas. Com o HTTP/2.0 essas mensagens simples são encapsuladas dentro de quadros (frames), enviabilizando a leitura direta. O princípio, porém, mantém-se o mesmo.

3. Lê a resposta do servidor.

4. Fecha ou reutiliza a conexão p/ requisições futuras.

### Mensagens HTTP

- Requisição

  - Method
  - Path
  - Versão de protocolo
  - Headers:
    - Host
    - Accept-Language

- Resposta

  - Versão de protocolo
  - Status code
  - Status message
  - Headers

### APIs baseadas no HTTP

A API mais utilizada construída em cima do HTTP é a XMLHttpRequest, que pode ser usada p/ trocar dados entre um agente-usuário e um servidor.

### Método HTTP idempotente

- > Def. — Um método idempotente é aquele em que _uma requisição idêntica pode ser feita uma ou mais vezes, em sequência, com o mesmo efeito, enquanto deixa o servidor no mesmo estado_.

- > Isso significa que, ao realizar uma requisição idempotente, _o resultado será sempre o mesmo_, independentemente do número de vezes que a requisição for feita.

- > Vide slides p/ entender as diferenças entre os _métodos GET, POST e DELETE_ quanto a idempotência.

### Método HTTP seguro

- > Def. — Um método HTTP é seguro se ele _não altera o estado do servidor_.

- > Em outras palavras, um método é seguro se ele leva a uma operação de _somente leitura_.

- > Diversos métodos HTTP são seguros, e.g. _GET, HEAD, ou OPTIONS_.

- > Todos os métodos seguros tbm são idempotentes, mas _nem todos os métodos idempotentes são seguros_.

  - > Por ex., PUT e DELETE são ambos idempotentes, entretanto são inseguros.

### Métodos de requisição HTTP

- GET
  > Solicita a _representação de um recurso_ específico. Deve retornar apenas dados.
- HEAD
  > Solicita uma resposta de forma idêntica ao método GET, porém _sem conter o corpo da resposta_.
- POST
  > É utilizado p/ _submeter uma entidade a um recurso específico_, frequentemente causando uma mudança no estado do recurso ou efeitos colaterais no servidor.
  - > Não permite que o visitante favorite a página.
- PUT
  > _Substitui todas as atuais representações_ do recurso de destino pela carga de dados da requisição.
- PATCH
  > É utilizado p/ aplicar _modificações parciais_ em um recurso.
- DELETE
  > _Remove_ um recurso específico.
- CONNECT
  > Estabelece um _túnel p/ o servidor_ identificado pelo recurso de destino.
- OPTIONS
  > É usado p/ descrever as _opções de comunicação_ com o recurso de destino.
- TRACE
  > Executa um _teste de chamada loop-back_ junto com o caminho p/ o recurso de destino.

### Portas padrões de protocolos

- HTTP: 80
- HTTPS: 443
- SSH: 22
- DNS: 53

### Códigos de status de resposta HTTP

- > Def. — São códigos numéricos que indicam a _natureza do resultado de uma requisição feita pelo cliente ao servidor_.

- > As respostas são agrupadas em _cinco classes_:

  - 100-199: Respostas de informação
  - 200-299: Respostas de sucesso
  - 300-399: Redirecionamentos
  - 400-499: Erros do cliente
  - 500-599: Erros do servidor

## 8.1.2 - WebSocket

- Introdução

  - > Def. — O WebSocket é um protocolo descrito na especificação RFC 6455 que fornece uma maneira de _trocar dados_ entre o navegador e o servidor através de uma _conexão persistente_.

  - > Depois que uma conexão de WebSocket é estabelecida, o cliente o servidor podem _enviar dados uns aos outros_.

  - > O WebSocket é especialmente excelente p/ _serviços que exigem troca contínua de dados_, e.g. chats, jogos online, sistemas de negociação em tempo real, etc.

- Segundo a especificação **RFC 6455**...

  - > O protocolo WebSocket permite a comunicação bidirecional entre um cliente executando código não confiável em um ambiente controlado e um host remoto que tenha optado por comunicações desse código.

  - > O modelo de segurança usado é baseado em origem, comum em navegadores da web.

  - > O protocolo consiste em um hand-shake de abertura seguido pelo envio de frames de mensagens, operando sobre TCP.

  - > O objetivo desta tecnologia é fornecer um mecanismo para aplicativos baseados em navegador que precisam de comunicação bidirecional com servidores e que não depende da abertura de várias conexões HTTP, como o XMLHttpRequest, iframe e long polling.

- Exemplo de conexão WebSocket em JavaScript:

  `let socket = new WebSocket("ws://exemplo.com");`

### WSS - WebSocket seguro

> Há tbm um `wss://`, que é um protocolo criptografado. É como o HTTPS p/ WebSockets.

### Eventos

> Depois que o socket é criado, podemos ouvir os eventos nele. Há um total de 4 eventos:

- `open`
  > Conexão estabelecida.
- `message`
  > Dados recebidos.
- `error`
  > Erro de WebSocket.
- `close`
  > Conexão fechada.

> Para enviar dados usamos `socket.send(data);`.

### Abrindo um WebSocket

#### Overview

- > Quando um WebSocket é criado, inicia um handshake (aperto de mão) HTTP (ou HTTPs p/ WSS).

- > O navegador pergunta ao servidor: "Você suporta WebSocket?"

- > E se o servidor disser "sim", a conversa continua no protocolo WebSocket, que não é HTTP.

#### Detalhamento

- Solicitação do navegador:

  > Exemplo:
  >
  > `new WebSocket("wss://exemplo.com.br/chat");`:

      GET /chat
      Host: exemplo.com.br
      Origin: https://exemplo.com.br
      Connection: Upgrade
      Upgrade: websocket
      Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
      Sec-WebSocket-Version: 13

  Cabeçalhos:

  - `Origin`

    > A `origem` da página do cliente.
    >
    > - O WebSocket é de `cross-origin` por natureza.
    >
    > - Não há cabeçalhos especiais ou outras limitações.
    >
    > - Os servidores antigos são incapazes de lidar com o WebSocket de qualquer maneira, portanto, não há problemas de combatibilidade.
    >
    > - O cabeçalho `Origin` é importante, pois permite que o servidor decida se deve ou não comunicar-se em WebSocket com o site de origem.

  - `Connection: Upgrade`

    > Sinaliza que o cliente gostaria de _alterar o protocolo_.

  - `Upgrade: websocket`

    > O protocolo solicitado é "websocket".

  - `Sec-WebSocket-Key`

    > Uma chave gerada aleatoriamente pelo navegador p/ _segurança_.

  - `Sec-WebSocket-Version`

    > _Versão_ do protocolo WebSocket. A atual é 13.

- Resposta do servidor:

  > Se o servidor concordar em mudar p/ WebSocket, ele deve enviar o código de resposta 101:

      101 Switching Protocols
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=

  - Aqui, `Sec-WebSocket-Accept` é o `Sec-WebSocket-Key` _recodificado_ usando um altoritmo especial. O navegador usa p/ garantir que a _resposta corresponda à solicitação_.

  - Posteriormente, os dados são transferidos usando o protocolo WebSocket.

### Dados WebSocket

- > A comunicação WebSocket consiste em _"frames"_ que podem ser enviados de ambos os lados.

- Tipos de frame WebSocket:

  - Frames de **texto**
    > Contêm dados de texto que as partes enviam entre si.
  - Frames de **dados binários**
    > Contêm dados binários que as partes enviam entre si.
  - Frames de **ping/pong**
    > São usados p/ verificar a conexão, enviados pelo servidor. O navegador responde-os automaticamente.
  - Frame de **conexão fechada**
  - E alguns outros _frames de serviços_...

- **Observações:**

  - > No navegador, nos preocupamos apenas com frames de _texto ou binários_.
    >
    > - O webSocket `.send()` pode enviar ambos os tipos.

  - > Os dados _textuais sempre vêm como string_.

  - > Já p/ receber dados _binários_, podemos escolher entre os formatos _Blob e ArrayBuffer_.

  ```js
  socket.bufferType = 'arraybuffer';
  socket.onmessage = (event) => {
    // event.data é uma string ou arraybuffer (se binário)
  };
  ```

### Encerramento da Conexão

#### Requisição de fechamento

- > Normalmente, quando uma parte deseja fechar a conexão, ela envia um "frame de fechamento de conexão" com um _código numérico_ e um _motivo textual_.

- > O navegador e o servidor têm _direitos iguais_.

- O método é:

  ```js
  socket.close([código], [razão]);
  ```

#### Resposta p/ fechamento

- > Em seguida, a outra parte no gerenciamento do evento close pode obter o código e o motivo. Por exemplo:

  ```js
  // um lado:
  socket.close(1000, 'Tarefa concluída');

  // outro lado:
  socket.onclose = (event) => {
    event.code === 1000;
    event.reason === 'Tarefa concluída';
    // event.wasClean === true (fechamento limpo)
  };
  ```

- **Código de fechamento**

  > O código de fechamento não é um número qualquer, mas um _especial do WebSocket_.

  - Principais:

    - `1000`
      > O _padrão_. Fechamento normal.
    - `1006`
      > Indica que a _conexão foi interrompida_ (sem frame de fechamento). Não se pode definir esse código manualmente.

  - Outros código:

    - `1001`
      > O servidor está sendo desligado ou um navegador saiu da página.
    - `1009`
      > A mensagem é muito grande p/ processar.
    - `1011`
      > Erro inesperado do servidor.

#### Estado da conexão

- > Para obter o estado da conexão, há também a propriedade `socket.readyState`, com valores:

  - 0 - CONNECTING
    > A conexão ainda não foi estabelecida.
  - 1 - OPEN
    > Comunicando.
  - 2 - CLOSING
    > A conexão está sendo fechada.
  - 3 - CLOSED
    > A conexão está fechada.

# 8.2 - DevOps, DevSecOps e Processos Contínuos

## 8.2.1 - DevOps

### Introdução

- > Def. — Formada pela combinação de "desenvolvimento" e "operações", a palavra "DevOps" fornece um ponto de partida p/ entender o que as pessoas geralmente querem dizer quando a dizem.

- > Notavelmente, o DevOps _não é_ um processo, tecnologia ou padrão.

- > Muitos se referem ao DevOps como uma "cultura" — "cultura DevOps".

- > Também usa-se o termo "movimento DevOps" ao falar sobre tópicos como taxas e tendências de adoção p/ o futuro,

- > e "ambiente DevOps" p/ se referir a uma organização de TI que adotou uma cultura DevOps.

- [ Vide SLIDES p/ o restante da introdução à DevOps. ]

### DevOps, Agile e SRE

- Agile (ágil) e Lean (enxuto)

  - > É como as equipes interagem, com ciclos de desenvolvimento curtos e feedback rápido.

  - > O Agile se _concentra na cultura_ e é _agnóstico a ferramentas_.

- DevOps

  - > É como as organizações de engenharia colaboram usando _equipes multifuncionais_.

  - > O DevOps _começa com a cultura_ e se _direciona p/ as ferramentas_.

- SRE (Software Reliability Engineering)

  - > Em português, **Engenharia de Confiabilidade do Sistema**.

  - > Def. — É como as organizações de engenharia _automatizam_, confiando _operações altamente dimensionadas_ a pessoas com uma _mentalidade de Engenharia de Software_.

  - > O SRE _começa com ferramentas_ e _impulsiona a cultura_.

- [ Vide SLIDE p/ diagrama relacionando e comparando DevOps e SRE. ]

### As variantes do DevOps

- > Envolvem a inserção ou adição de outra disciplina/prática no início do Ciclo de Vida de Desenvolvimento de Software (SDLC).

- > A prevalência desses diferentes tipos de DevOps se refere à _crescente integração de funções nas organizações modernas_.

- > Ex.: DevSecOps.

### Como funciona o DevOps?

> [ SLIDE ]

### Colaboração

> [ SLIDE ]

### Automação

> [ SLIDE ]

### Integração Contínua (Continuous Integration - CI)

> [ SLIDE ]

### Teste Contínuo

> [ SLIDE ]

### Entrega Contínua (Continuous Delivery - CD)

> [ SLIDE ]

### Monitoramento Contínuo

> [ SLIDE ]

### Conclusão

> [ SLIDE ]

## 8.2.2 - DevSecOps

### Introdução

- **Sem DevSecOps:**

  - > A _segurança_ era "acrescentada" ao software _no final_ do ciclo de desenvolvimento.

  - > _Atualizações de software_ eram liberadas apenas _uma ou duas vezes por ano_.

  - > Com metodologias ágeis, _a segurança virou um gargalo_.

- **Com DevSecOps:**

  - Desenvolvimento, Segurança e Operações

  - > Incorpora a Segurança _em todas as fases_ do Ciclo de Vida de Desenvolvimento de Software (SDLC).

    - > Em outros termos, foi adicionada uma **camada de segurança** _em volta de todas as etapas_ do processo DevOps.

  - > Permite o desenvolvimento de **software seguro** _na velocidade do Agile e do DevOps_.

  - > Aborda os **problemas de segurança** à medida que surgem, quando _são mais fáceis, rápidos e baratos de corrigir_.

  - > A segurança de aplicativos e infraestrutura é uma **responsabilidade compartilhada** das equipes de desenvolvimento, segurança e operações de TI.

#### Implantando DevSecOps

- Planejar
  - **Analyse**
    > Identificar seu próximo desafio de segurança mais crítico.
- Codificar
  - **Secure**
    > Implementar uma estratégia de defesa.
- Buildar (Compilar)
- Testar Continuamente
  - **Verify**
    > Automatizar os testes de segurança.
- Entregar
- Implantar
- Operar
  - **Defend**
    > Detectar ataques e impedir a exploração (exploit).
- Monitorar

#### Benefícios

- Entrega de software rápida e com boa relação custo-benefício.

- Segurança aprimorada e proativa.

- Correção de vulnerabilidade de segurança acelerada.

- Automação compatível com o desenvolvimento moderno.

- Processo repetível e adaptativo.

### Práticas

#### Shift Left

- > Def. — Incentivar os engenheiros de software a _mover a segurança da direita (final) p/ a esquerda (início)_ do processo DevOps.

- > Arquitetos e Engenheiros de Segurança Cibernética fazem parte da equipe de desenvolvimento.

- Etapas:

  - Treinar
    > Left
  - Projetar
    > Left
  - Codificar
    > Left
  - Implantar
    > Center
  - Hackear
    > Right
  - Monitorar
    > Right

#### Educação de Segurança

- > Def. — Garantir que todos na organização _entendam a postura de segurança da empresa_ e sigam os mesmos padrões.

- > Todos os envolvidos no processo de entrega devem estar familizarizados com:

  - Os princípios básicos de segurança de aplicativos,
  - Os dez primeiros projetos de segurança de aplicativos da web (OWASP),
  - Testes de segurança de aplicativos,
  - E outras práticas de engenharia de segurança.

#### Cultura: Comunicação, Pessoas, Processos e Tecnologia

- > É essencial _comunicar as responsabilidades de segurança_ dos processos e propriedade do produto.

- > A equipe cria o ambiente de fluxo de trabalho _que atenda às suas necessidades_.

- > Os profissionais _se tornam interessados_ no resultado do projeto.

#### Rastreabilidade

- > Def. — Permite _rastrear itens de configuração_ em todo o ciclo de desenvolvimento até onde os requisitos são implementados no código.

#### Auditabilidade

- > Def. — Os controles de segurança _técnicos, procedimentais e administrativos_ precisam ser:

  - Auditáveis,
  - Bem documentados,
  - E respeitados por todos os membros da equipe.

#### Visibilidade

- > A organização deve possuir um sistema de monitoramento sólido p/:

  - Medir o _ritmo da operação_,
  - Enviar _alertas_,
  - Aumentar a _conscientização sobre mudanças e ataques cibernéticos_ à medida em que ocorrem,
  - E fornecer _responsabilidade_ durante todo o ciclo de vida do projeto.

## 8.2.3 - Processos Contínuos: Integração Contínua (CI), Entrega Contínua (CD) e Implantação Contínua

### Introdução

#### Integração Contínua (Continuous Integration – CI)

- > Def. — A Integração Contínua é o _processo de automatizar a criação e o teste de código_ toda vez que um membro da equipe entrega alterações no controle de versão.

- > O CI incentiva os desenvolvedores a compartilharem seus códigos e testes de unidade _mesclando suas alterações em um repositório de controle de versão compartilhado_ após cada pequena conclusão de tarefa.

- > O código de confirmação aciona um _sistema de compilação automatizado_ p/ capturar o código mais recente do repositório compartilhado e p/ _construir, testar e validar_ a branch (ramo) principal.

#### Testes Automatizados

- > Def. — São testes que podem ser executados _de maneira repetitiva e a qualquer momento_, sem a necessidade de intervenção humana.

- > Normalmente deve-se escrever um **script** p/ _testar algumas afirmações (asserts)_ ou _validar o comportamento do aplicativo_.

- > O script é então executado por uma máquina que fornece os resultados como uma saída.

- > O Teste Automatizado é uma parte essencial do CI, _mas não é suficiente por si só_.

#### Entrega Contínua (Continuous Delivery – CD)

- > Def. — É uma _extensão_ da Integração Contínua p/ garantir que se possa _liberar novas alterações_ p/ os clientes _rapidamente e de maneira sustentável_.

- > Isso significa que, além de automatizar os testes, tbm _automatiza-se o processo de liberação_, permitindo assim implantar o aplicativo _a qualquer momento_.

- > Em teoria, com a Entrega Contínua, pode-se decidir entregar diariamente, semanalmente, quinzenalmente, ou _o que for adequado_ às necessidades comerciais.

  - > No entanto, se realmente deseja-se obter os benefícios da entrega contínua, _implanta-se na produção o mais cedo possível_, p/ ter certeza de liberar pequenos lotes que sejam _fáceis de corrigir em caso de problema_.

#### Implantação Contínua (IC, CI)

- > Vai _um passo além_ da Entrega Contínua.

- > Def. — Com essa prática, todas as alterações _que passam por todos os estágios do pipeline de produção_ são liberados p/ os clientes.

- > _Não há intervenção humana_, e somente um **teste com falha** impedirá que uma nova mudança seja implantada em produção.

- > A Implantação Contínua é uma excelente maneira de _acelerar o ciclo de feedback com os clientes_ e _tirar a pressão da equipe_, já que não há mais um "dia de implantação".

  - > Os desenvolvedores podem _se concentrar na criação do software_, e eles veem o seu trabalho implantado minutos depois de terem terminado de trabalhar nele.

#### Diagrama CI/CD/CD

- [ Vide SLIDE ]

### Requisitos e Benefícios da CI, CD e CD

#### Integração Contínua

- Requisitos:

  - > A equipe precisará _escrever testes_ p/ cada novo recurso, melhoria ou correção de bug.

  - > É necessário um **servidor de Integração Contínua** que possa monitorar o repositório principal e executar os testes automaticamente _p/ cada novo commit enviado_.

  - > Os desenvolvedores precisam mesclar (mergear) suas alterações _com a maior frequência possível_, pelo menos uma vez por dia.

- Benefícios:

  - > **Menos bugs** são enviados p/ produção à medida em que os _erros são capturados antecipadamente_ pelos testes automatizados.

  - > Construir a versão de implantação é fácil, pois todos os _problemas de integração foram resolvidos cedo_.

  - > **Menos troca de contexto**, pois os desenvolvedores são alertados assim que quebram a compilação, podendo _trabalhar p/ corrigi-la antes de passar p/ outra tarefa_.

  - > Os **custos de teste** são _reduzidos drasticamente_ — o servidor de CI pode executar centenas de testes em questão de segundos.

  - > A equipe de Controle de Qualidade passa **menos tempo testando**, e pode se concentrar em _melhorias significativas na cultura de qualidade_.

#### Entrega Contínua

- Requisitos:

  - > É necessária uma **base sólida em Integração Contínua**, e sua _Suíte de Testes precisa cobrir o suficiente_ da sua base de código.

  - > **Implantações precisam ser automatizadas**.

    - > _O acionador ainda é manual_, mas uma vez iniciada a implantação, não deve haver necessidade de intervenação humana.

  - > [Questionável] A equipe pode incluir **Sinalizadores de Funcionalidades (Feature Flags)** p/ que as funcionalidades incompletas não afetem os clientes na produção.

- Benefícios:

  - > A **complexidade da implantação de software é diminuída**.

    - > O time não precisa mais passar dias se preparando p/ uma implantação.

  - > Pode-se **implantar com mais frequência**, acelerando assim o ciclo de feedback com seus clientes.

  - > Há **menos pressão** nas decisões p/ pequenas mudanças, incentivando portanto uma _interação mais rápida_.

#### Implantação Contínua

- Requisitos:

  - > A **cultura de testes** _precisa estar no seu auge_.

    - > A qualidade do conjunto de testes determinará a qualidade dos seus lançamentos.

  - > O **processo de documentação** precisará _acompanhar o ritmo das implantações_.

  - > A **Sinalização de Funcionalidades** se torna _parte inerente_ do processo de liberação de mudanças significativas, p/ garantir que se possa _coordenar com outros departamentos_ (Suporte, Marketing, RP, etc).

- Benefícios:

  - > Pode-se **desenvolver mais rápido**, pois não há necessidade de pausar o desenvolvimento p/ implantações.

    - > Os _pipelines de implantação são acionados automaticamente_ p/ cada alteração.

  - > As **liberações são menos arriscadas** e _mais fáceis de corrigir em caso de problema_, à medida que se implanta pequenos lotes de alteração.

  - > Os **clientes veem um fluxo contínuo de melhorias**, e a qualidade aumenta a cada dia, em vez de a cada mês, trimestre ou ano.

### Proteção da qualidade com Construções Contínuas & Automação de Testes

> A Integração Contínua combina Construções Contínuas com Automação de Testes p/ _garantir que cada construção também avalie a qualidade da base de código_.

#### Construções Contínuas

- > Def. — Construir o projeto _assim que uma alteração é feita_.

- > Idealmente, o Delta entre cada compilação é um único conjunto de mudanças.

#### Automação de Testes

- > Def. — _Validação programática do software_ p/ garantir a Qualidade.

- > Os testes podem iniciar ações no software a partir da Interface do Usuário (UI) ou da camada de serviços do Back-end.

### Testes na CI: Testes Unitários, de API e Funcionais

- > As execuções de CI têm **duas fases** principais:

  1. Primeira Fase — Testes Unitários e de API

     > Garante que o código _seja compilado ou unificado_.

  2. Segunda Fase — Testes Funcionais

     > Garante que o código _funcione conforme projetado_.

     - > A maneira mais certa de fazer isso é com uma série de Testes Automatizados _que validam todos os níveis do produto_.

#### Testes Unitários

- Vantagens:

  > - _Fáceis de escrever_.
  > - _Executam rapidamente_.
  > - _Modelam de perto_ a arquitetura da base de código.

- Desvantagens:

  > - _Validam apenas os principais componentes do software_.
  > - _Não refletem fluxos de trabalho do usuário_, que geralmente envolvem vários componentes trabalhando juntos.

#### Testes de API

- Introdução:

  - > Um **bom software é modular**, pois isso permite uma _separação mais clara do trabalho em várias aplicações_.

  - > Def. — Validam APIs fazendo chamadas de um módulo p/ outro.

    - > Def. de API — Pontos Finais (Endpoints) nos quais diferentes módulos se comunicam entre si.

- Benefícios:

  > - Geralmente _fáceis de escrever_.
  > - _Executam rapidamente_.
  > - _Modelam facilmente_ como os aplicativos irão interagir entre si.

- Desvantagem:

  > - Em códigos simples, _podem imitar alguns testes de unidade_.

#### Testes Funcionais

- Introdução:

  - > Def. — Testes Funcionais funcionam em áreas maiores da base de código e modelam Fluxos de Trabalho (Workflow) de usuário.

  - > Em aplicativos web, por exemplo, HTTPUnit e Selenium interagem diretamente com a UI p/ testar o produto.

- Benefício:

  > - _Mais propensos a encontrar erros_, pois eles imitam as ações do usuário e testam a interoperabilidade de vários componentes.

- Desvantagens:

  > - _Mais lentos_ que os Testes de Unidade.

  > - Às vezes relatam _falsos negativos_ devido a (1) a latência da rede ou (2) uma interrupção momentânea em algum ponto da pilha tecnológica.

# 8.3 - Práticas de Programação Segura

## 8.3.1 - Introdução

Referência:

- Melhores Práticas de Codificação Segura OWASP – Guia de Referência Rápida
  > OWASP Secure Coding Pratices – Quick Reference Guide

### Programação Segura

- Def. — A Codificação Segura, t.c.c. Programação Segura, envolve a _escrita de código em uma linguagem de alto nível que segue Princípios rígidos_, com o objetivo de **evitar possíveis Vulnerabilidades** que podem expor dados ou causar danos em um sistema de destino.

## 8.3.2 - Checklist OWASP

1. Validação dos Dados de Entrada
2. Codificação dos Dados de Saída
3. Autenticação e Gerenciamento de Credenciais
4. Gerenciamento de Sessões
5. Controle de Acesso
6. Práticas de Criptografia
7. Tratamento de Erros e Log
8. Proteção de Dados
9. Segurança nas Comunicações
10. Configuração do Sistema
11. Segurança em Banco de Dados
12. Gerenciamento de Arquivos
13. Gerenciamento de Memória

### 1 - Validação dos Dados de Entrada

- > Realização de validação de dados em **sistemas confiáveis**.

- > Validação de condução e Identificação de dados **em termos de fontes confiáveis e não confiáveis**.

- > Validação de dados com base no tipo de dados, intervalo e comprimento de entrada em relação a uma **lista de caracteres permitidos**.

- > Verificar e Validar se os valores nos cabeçalhos de solicitações e respostas **estão apenas em caracteres ASCII**.

- > Validar todos os dados fornecidos pelo Cliente/Usuário **antes que os dados sejam processados**, incluindo URLS, cabeçalhos HTTP, código incorporados, etc.

### 2 - Codificação dos Dados de Saída

- > Validar dados em um **sistema confiável** (Servidor).

- > **Codificar todos os caracteres**, a menos que sejam considerados _seguros_ p/ o interpretador de destino.

- > **Sanitização de saída de dados não-confiáveis** usando comandos do SO.

### 3 - Autenticação e Gerenciamento de Credenciais

- > **Requerer Autenticação p/ todas as páginas e recursos**, exceto p/ aqueles que são intencionalmente públicos.

- > **Impedir a reutilização de senhas.**

- > **Notificar os Usuários** quando ocorrer uma _redefinição de senha_.

- > **Relatar o número de falhas de login ao Usuário** no próximo login bem-sucedido.

- > **Manter um tempo de expiração curto p/ senhas temporárias** que precisam ser alteradas no próximo login.

- > Exigir que as senhas sejam definidas com base na **política de complexidade de senha**.

### 4 - Gerenciamento de Sessões

- > Sessões e conexões devem ser **totalmente encerradas após o logout**.

- > **Vários logins não devem ser permitidos** no mesmo ID de usuário.

- > _Com base nos riscos e objetivos de negócio_, o intervalo de tempo limite de inatividade da sessão **deve ser o mais baixo possível**.

### 5 - Controle de Acesso

- > **Somente Usuários autorizados devem ter acesso** a URLs protegidas, serviços, dados de aplicativos, dados de Usuários, atributos, etc.

- > **A auditoria de contas deve ser implementada** e as contas não utilizadas devem ser excluídas.

- > _As contas associadas a diferentes serviços_ p/ sistemas externos ou internos que são usados principalmente p/ tarefas não críticas **devem ser Privilégios Mínimos**.

- > **O número de transações deve ser limitado** p/ um único Usuário ou dispositivo durante um determinado período de tempo.

### 6 - Práticas de Criptografia

- > Um **sistema confiável** deve ser usado p/ implementar funções critográficas p/ _manter a confiabilidade de dados confidenciais_ no aplicativo.

- > A geração de números aleatórios, nomes de arquivo, GUID e strings deve usar um **gerador de números alatórios aprovado**.

- > O **gerenciamento de chaves criptográficas** deve ser empregado desenvolvendo e usando _processos e políticas_.

- > **As chaves mestras devem ser protegidas contra acesso não autorizado**.

### 7 - Tratamento de Erros e Log

- > Manipuladores de erro _que não descartam informações de depuração em caso de entrada não solicitada_ devem ser usados.

- > Quando ocorrem condições de erro, _a memória deve ser liberada adequadamente_.

- > Os logs _não devem armazenar informações confidenciais_ relacionadas a sistemas, sessões, etc.

- > Os logs relacionados a falhas de validação de entrada, tentativas de autenticação, controle de acesso, exceções do sistema, alterações inesperadas nos dados e alterações feitas nas configurações de segurança _devem ser mantidos e verificados minuciosamente_.

### 8 - Proteção de Dados

- > _Seguir o Princípio do Privilégio Mínimo_, limitando os direitos e privilégios dos usuário aos sistemas, informações e usabilidade necessários p/ atingir as metas e objetivos exigidos.

- > Excluir dados confidenciais de requisições GET em HTTP.

- > _Proteger o código do lado do servidor e Evitar que ele seja acessível pelo usuário comum_. O controle de acesso adequado deve ser implementado p/ dados críticos e confidenciais.

- > _O recurso de preenchimento automático deve ser excluído_ ao inserir dados em formulários de sites ou aplicativos.

### 9 - Segurança nas Comunicações

- > No caso do TLS, as conexões com falha _não devem fazer downgrade p/ protocolos não seguros_.

- > P/ proteção de informações confidenciais sobre fontes externas, _deve ser usado o TLS_.

- > Todas as conexões devem ser _especificadas com codificação de caracteres_.

### 10 - Configuração do Sistema

- > Deve-se certificar de que os sistemas e suas estruturas e componentes estejam _executando as versões e patches mais recentes_.

- > O Privilégio Mínimo também deve ser aplicado _em contas de serviços, servidores web e processos_.

- > _Os cabeçalhos de resposta HTTP devem incluir apenas informações relevantes_. Informações sobre SO, versão do servidor web e estruturas de software não devem ser incluídas.

### 11 - Configuração do Sistema

- > Deve-se certificar de que os sistemas e suas estruturas e componentes estejam executa

### 12 - Segurança em Banco de Dados

- [ Vide slide p/ diagrama do Ciclo de Segurança em BD. ]

- > Ao acessar o BD, o aplicativo deve usar o _nível de privilégio mais baixo possível_ (Princípio do Privilégio Mínimo).

- > _As senhas padrão devem ser alteradas imediatamente_. A Higiene de Senha deve ser mantida em mente ao atribuir senhas a contas.

- > Deve-se _habilitar Autenticação Multifator_ quando aplicável.

- > Deve-se _desativar as contas padrão_ que não são necessárias p/ os requisitos de negócio.

### 13 - Gerenciamento de Arquivos

- > _Deve-se garantir a Autenticação_ ao carregar um arquivo no Servidor.

- > Os arquivos carregados no servidor _devem ser validados verificando os cabeçalhos dos arquivos_.

- > _Os Privilégios de Execução devem ser desativados_ nos diretórios onde os arquivos são carregados.

- > _O caminho absoluto do arquivo_ nunca deve ser enviado ao cliente.

### 14 - Gerenciamento de Memória

- > Funções vulneráveis como `print`, `strcat` e `strcpy` devem ser evitadas.

- > _O tamanho do buffer deve ser verificado_ quanto a estouros.

- > _As strings de entrada devem ser truncadas corretamente_ antes que funções como cópia e concatenação sejam usadas.

## 8.2.3 - Boas Práticas Gerais de Codificação

- P/ tarefas comuns, **utilizar sempre código testado, gerenciado e aprovado** ao invés de criar código novo e não gerenciado.

  > Evitar "reinventar a roda".

- **Utilizar APIs que executem tarefas específicas para realizar operações do SO.** _Não permitir que a aplicação execute comandos diretamente no SO_, especialmente através da utilização de “shells” de comando iniciadas pela aplicação.

  > P/ que o atacante não tome conta do shell.

- **Utilizar mecanismos de verificação de integridade** por "checksum" ou "hash" _p/ verificar a Integridade_ do código interpretado, bibliotecas, arquivos executáveis e arquivos de configuração.

- Utilizar mecanismos de bloqueio p/ **evitar requisições simultâneas** p/ a aplicação ou Utilizar um mecanismo de sincronização p/ **evitar Condições de Concorrência** (Race Conditions).

- Proteger _as variáveis compartilhadas e os recursos_ contra **acessos concorrentes inapropriados**.

- **Instanciar explicitamente** todas as variáveis e dados persistentes durante a declaração, ou antes da primeira utilização.

  > Inclusive saneando eventuais lixos de memória, mais comuns em linguagens como C.

- Quando a aplicação tiver que ser executada com o Privilégios elevados, **aumentar os privilégios o mais tarde possível e revogá-los logo que seja possível**.

- **Evitar erros de cálculo** decorrentes da falta de entendimento _da representação interna da linguagem de programação usada_ E _de como é realizada a interação com os aspectos de cálculo numérico_.

  > Prestar atenção nas discrepâncias de tamanho de byte, precisão, distinções de sinal (signed/unsigned), truncamento, conversão e “casting” entre os tipos, cálculos que devolvam erros do tipo “not-a-number” e, também, como a linguagem de programação trata a representação interna de números muito grandes ou muito pequenos;

- **Não transferir diretamente** dados fornecidos pelo usuário p/ qualquer função de execução dinâmica _sem realizar o tratamento dos dados de modo adequado_.

  > E.g. envio p/ o navegador de código em script que pode ser executado dinamicamente.

- **Restrigir a geração e a alteração de código** por parte dos usuários.

- **Revisar todas as aplicações secundárias, códigos e bibliotecas de terceiros** p/ determinar a necessidade de negócio e validar as funcionalidades de segurança, uma vez que estas podem _introduzir novas Vulnerabilidades_.

- **Implementar atualizações de modo seguro.**

  - > Se a aplicação precisar realizar atualizações automáticas, _utilizar mecanismos de assinatura digital_ p/ garantir a Integridade do código E garantir que os clientes façam a verificação da assinatura após descarregarem as atualizações.

  - > Usar _canais criptografados_ p/ transferir o código a partir do host do servidor.

# 8.4 - Testes de Software

## 8.4.1 - Introdução

- > Def. — Processo destinado a mostrar que um programa _faz o que é proposto a fazer_ e p/ _descobrir os Defeitos do programa antes do uso_.

- O Processo de Testes tem **2 objetivos distintos**:

  1. > Demonstrar ao desenvolvedor e ao Cliente que _o software atende a seus Requisitos_.

  2. > Descobrir situações em que o software _se comporta de maneira incorreta, indesejável ou de forma diferente das especificações (Defeitos)_.

- O primeiro objetivo leva a **Testes de Validação**.

  > Aqui espera-se o Sistema seja executado corretamente _usando um determinado conjunto de Casos de Teste que refletem o uso esperado do sistema_.

- O segundo objetivo leva a **Testes de Defeitos**.

  > Aqui os Casos de Teste são projetados p/ expor os Defeitos do sistema. Eles podem ser _deliberadamente obscuros e não precisam refletir com precisão a maneira como o sistema costuma ser usado_.

- **Não existem limites definidos** entre essas duas abordagens de Teste:

  - > Durante os Testes de Validação, _pode-se encontrar Defeitos no sistema_;

  - > E durante os Testes de Defeito, alguns Testes _poderão mostrar que o programa corresponde a seus Requisitos_.

### Para pensar

- BOEHM, 1979:

  - **Validação**

    > Estamos construindo produto certo?

  - **Verificação**

    > Estamos construindo o produto da maneira certa?

- DIJKSTRA et al., 1972:

  > Os testes podem mostrar apenas a _presença de erros_, e não a sua _ausência_.

### Validação e Verificação – V&V

- **Validação**

  > Seu objetivo é checar se o software _atende a seus **Requisitos** Funcionais e Não-Funcionais_.

- **Validação**

  > É um processo mais geral. Objetiva-se garantir que o software _atenda às expectativas do **Cliente**_.

### Inspeções e Revisões (Análise Estática)

- > Assim como Testes de Software o processo V&V pode incluir as Inspeções e Revisões, t.c.c. Análise Estática.

- > Def. — A Análise Estática analisa e verifica os _Requisitos de Sistema, modelos de projeto, o código-fonte e até mesmo os Testes de Software propostos_.

- > Essas são chamadas técnicas "estáticas" de V&V, em que _não é preciso executar o software_ p/ verificá-lo.

- > As Inspeções centram-se principalmente no código-fonte, mas _qualquer representação legível do software_, como seus requisitos ou modelo de projeto, _pode ser inspecionada_.

### Teste de Inspeção

[ VS p/ diagrama ]

**Inspeções cobrem:**

- Especificação de Requisitos
  - Protótipo de sistema
    - Cobertos por **Testes de Software**.
- Arquitetura de software
- Modelos de projeto em UML
- Esquemas de BD
- Programa (Código-fonte)
  - Cobertos por **Testes de Software**.

### Vantagens

[ VS p/ mais detalhes. ]

- Há **3 vantagens** das Inspeções sobre os Testes:

  1. Durante os testes, **erros podem mascarar (esconder) outros erros**.

  2. **Versões incompletas de um sistema** podem ser inspecionadas sem custos adicionais.

  3. Uma inspeção **pode considerar outros atributos de qualidade de um software**, como a conformidade com os padrões, portabilidade e manutebilidade.

- **Discussão:**

  - As inspeções de software são uma ideia antiga, e vários estudos e experimentos demonstraram que _as Inspeções **são mais eficazes** na descoberta de defeitos do que os Testes_.

  - No entanto, as **Inspeções não são boas p/ descobrir**:
    - Descobrir defeitos que surgem devido a interações inesperadas entre diferentes partes de um software,
    - Problemas de timing,
    - Baixo desempenho de um sistema.

### Modelos de Entrada-Saída de Teste

[ VS p/ diagrama ]

### Modelo V

[ VS p/ diagramas ]
