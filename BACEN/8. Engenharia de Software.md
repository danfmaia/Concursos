# BACEN - Disciplina 8 - Engenharia de Software (ES)

Prof. Tiago Lage Payne de Pádua

## Conhecimentos prévios

- Protocolo TPC - ???[TODO]

  > ???[TODO]

- Modelo OSI

  > _Modelo da camada de aplicação_ predominante.

  > Def. — O modelo OSI (Open Systems Interconnection) é um modelo de referência que _descreve como os dispositivos de rede se comunicam entre si_.

  > Ele é _dividido em sete camadas_: física, de enlace, de rede, de transporte, de sessão, de apresentação e de aplicação.

  > Cada camada possui funções específicas e trabalha em conjunto para garantir a _comunicação eficiente e confiável entre os dispositivos de rede_.

  > O modelo OSI é amplamente utilizado na área de redes de computadores para _facilitar o desenvolvimento, a implementação e a manutenção de sistemas de comunicação_.

## 8.1 - Protocolo HTTP

- Def. — Hypertext Transfer Protocol (HTTP) é um _protocolo de camada de aplicação p/ transmissão de documentos hipermídia_, como o HTML.

- Outros protocolos:

  - FTP - File Transfer Protocol
    > Transferência de arquivos. Pouco utilizado atualmente.
  - SMTP - Simple Mail Transfer Protocol
    > Correio eletrônico.
  - NSF - Network File System
    > Servidor remoto de arquivos.
  - SSH - Secure Shell
    > Acesso a terminal remoto.
  - Telnet
    > Acesso a terminal remoto. Muito pouco utilizado atualmente.

- Foi desenvolvido p/ _comunicação entre navevagores web e servidores web_, porém tbm pode ser utilizado p/ _outros propósitos_.

- Segue um _modelo cliente-servidor clássico_, onde um cliente abre uma conexão, executa uma requisição e espera até receber uma resposta.

- É tbm um protocolo _sem estado (stateless)_, que significa que o servidor não mantém nenhum dado entre duas requisições (state).

### Portas padrões de protocolos

- HTTP: 80
- HTTPS: 443
- SSH: 22
- DNS: 53

### Componentes de sistemas baseados em HTTP

- O HTTP é um protocolo **cliente-servidor**: as requisições são enviadas por uma _entidade_, o agente-usuário (ou um proxy em nome dele).

- A maior parte do tempo, o agente-usuário é um navegador da web, mas pode ser qualquer coisa, como por exemplo um robô que varre a web p/ preencher e manter um índice de mecanismo de pesquisa e coletar informações.

- Cada _requisição (request)_ individual é enviada p/ um servidor, que irá lidar com isso e fornecer um resultado, chamado de _resposta (response)_.

- Entre a requisição e a resposta existem várias entidades, designadas coletivamente como _proxies_, que executam operações diferentes e atuam como gateways (intermediários) ou caches, por exemplo.

### Cliente: o agente-usuário

- Def. — O agente-usuário é qualquer ferramenta que _age em nome do usuário_.

- Essa função é predominantemente realizada pelo navegador web.

- O agente-usuário _sempre é a entidade que inicia as requisições_, nunca o lado do servidor.
  > Embora alguns mecanismos tenham sido adicionados ao longo dos anos p/ simular mensagens iniciadas pelo servidor.

### Servidor (web)

- Do outro lado do canal de comunicação está o servidor, que serve o documento requisitado pelo usuário.

- Um servidor se apresenta virtualmente como uma única máquina.
  > Isto porque o servidor pode ser uma _coleção de servidores dividindo a carga_—através de uma técnica chamada _balanceamento de carga (load balancer)_—ou também como um programa complexo que _acessa outros servidores_ (como um cache, um servidor de banco de dados, servidores e-commerce, etc), gerando todo ou parte do documento solicitado.

### Proxies

- Entre o navegador web e o servidor, _vários computadores e máquinas transmitem as mensagens HTTP_.

- Devido a estrutura em camadas da pilha web, _a maioria dessas máquinas operam em alguma das camadas_ (de transporte, de rede ou física), sendo _transparentes_ na camada da aplicação HTTP, e potencialmente exercendo um grande impacto na performance.

- Essas _máquinas que operam na camada de aplicação são normalmente conhecidas como proxies_ (ou representantes, ou procuradores).

### Aspectos básicos do HTTP

- Simples.
- Extensível.
  > Cabeçalhos (headers).
- Não tem estado, mas tem sessões.
  > Cookies.
- HTTP e conexões.
  > O HTTP utiliza apenas o protocolo de conexão TCP, por ser um protocolo confiável. Há tbm o protocolo UDP, que não é confiável e possui casos de uso diferentes.

### O que pode ser controlado pelo HTTP

- Cache
- Relaxamento das restrições na origem
- Autenticação
  > Basic Authentication. Não é recomendado.
- Proxy e tunelamento
- Sessões
  > Cookies.

### Fluxo HTTP

1. Abre uma conexão TCP.

   > A conexão TCP será usada p/ enviar uma requisição, ou várias, e receber uma resposta. O cliente pode abrir uma nova conexão, reusar uma conexão existente, ou abrir várias conexões ao servidores.

2. Envia uma mensagem HTTP.

   > Mensagens HTTP antes do HTTP/2.0 são legíveis às pessoas. Com o HTTP/2.0 essas mensagens simples são encapsuladas dentro de quadros (frames), enviabilizando a leitura direta. O princípio, porém, mantém-se o mesmo.

3. Lê a resposta do servidor.

4. Fecha ou reutiliza a conexão p/ requisições futuras.

### Mensagens HTTP

- Requisição

  - Method
  - Path
  - Versão de protocolo
  - Headers:
    - Host
    - Accept-Language

- Resposta

  - Versão de protocolo
  - Status code
  - Status message
  - Headers

### APIs baseadas no HTTP

A API mais utilizada construída em cima do HTTP é a XMLHttpRequest, que pode ser usada p/ trocar dados entre um agente-usuário e um servidor.

### Método HTTP idempotente

- > Def. — Um método idempotente é aquele em que _uma requisição idêntica pode ser feita uma ou mais vezes, em sequência, com o mesmo efeito, enquanto deixa o servidor no mesmo estado_.

- > Isso significa que, ao realizar uma requisição idempotente, _o resultado será sempre o mesmo_, independentemente do número de vezes que a requisição for feita.

- > Vide slides p/ entender as diferenças entre os _métodos GET, POST e DELETE_ quanto a idempotência.

### Método HTTP seguro

- > Def. — Um método HTTP é seguro se ele _não altera o estado do servidor_.

- > Em outras palavras, um método é seguro se ele leva a uma operação de _somente leitura_.

- > Diversos métodos HTTP são seguros, e.g. _GET, HEAD, ou OPTIONS_.

- > Todos os métodos seguros tbm são idempotentes, mas _nem todos os métodos idempotentes são seguros_.

  - > Por ex., PUT e DELETE são ambos idempotentes, entretanto são inseguros.

### Métodos de requisição HTTP

- GET
  > Solicita a _representação de um recurso_ específico. Deve retornar apenas dados.
- HEAD
  > Solicita uma resposta de forma idêntica ao método GET, porém _sem conter o corpo da resposta_.
- POST
  > É utilizado p/ _submeter uma entidade a um recurso específico_, frequentemente causando uma mudança no estado do recurso ou efeitos colaterais no servidor.
  - > Não permite que o visitante favorite a página.
- PUT
  > _Substitui todas as atuais representações_ do recurso de destino pela carga de dados da requisição.
- PATCH
  > É utilizado p/ aplicar _modificações parciais_ em um recurso.
- DELETE
  > _Remove_ um recurso específico.
- CONNECT
  > Estabelece um _túnel p/ o servidor_ identificado pelo recurso de destino.
- OPTIONS
  > É usado p/ descrever as _opções de comunicação_ com o recurso de destino.
- TRACE
  > Executa um _teste de chamada loop-back_ junto com o caminho p/ o recurso de destino.

### Portas padrões de protocolos

- HTTP: 80
- HTTPS: 443
- SSH: 22
- DNS: 53

### Códigos de status de resposta HTTP

- > Def. — São códigos numéricos que indicam a _natureza do resultado de uma requisição feita pelo cliente ao servidor_.

- > As respostas são agrupadas em _cinco classes_:

  - 100-199: Respostas de informação
  - 200-299: Respostas de sucesso
  - 300-399: Redirecionamentos
  - 400-499: Erros do cliente
  - 500-599: Erros do servidor

## 8.2 - WebSocket

- Introdução

  - > Def. — O WebSocket é um protocolo descrito na especificação RFC 6455 que fornece uma maneira de _trocar dados_ entre o navegador e o servidor através de uma _conexão persistente_.

  - > Depois que uma conexão de WebSocket é estabelecida, o cliente o servidor podem _enviar dados uns aos outros_.

  - > O WebSocket é especialmente excelente p/ _serviços que exigem troca contínua de dados_, e.g. chats, jogos online, sistemas de negociação em tempo real, etc.

- Segundo a especificação **RFC 6455**...

  - > O protocolo WebSocket permite a comunicação bidirecional entre um cliente executando código não confiável em um ambiente controlado e um host remoto que tenha optado por comunicações desse código.

  - > O modelo de segurança usado é baseado em origem, comum em navegadores da web.

  - > O protocolo consiste em um hand-shake de abertura seguido pelo envio de frames de mensagens, operando sobre TCP.

  - > O objetivo desta tecnologia é fornecer um mecanismo para aplicativos baseados em navegador que precisam de comunicação bidirecional com servidores e que não depende da abertura de várias conexões HTTP, como o XMLHttpRequest, iframe e long polling.

- Exemplo de conexão WebSocket em JavaScript:

  `let socket = new WebSocket("ws://exemplo.com");`

### WSS - WebSocket seguro

> Há tbm um `wss://`, que é um protocolo criptografado. É como o HTTPS p/ WebSockets.

### Eventos

> Depois que o socket é criado, podemos ouvir os eventos nele. Há um total de 4 eventos:

- `open`
  > Conexão estabelecida.
- `message`
  > Dados recebidos.
- `error`
  > Erro de WebSocket.
- `close`
  > Conexão fechada.

> Para enviar dados usamos `socket.send(data);`.

### Abrindo um WebSocket

#### Overview

- > Quando um WebSocket é criado, inicia um handshake (aperto de mão) HTTP (ou HTTPs p/ WSS).

- > O navegador pergunta ao servidor: "Você suporta WebSocket?"

- > E se o servidor disser "sim", a conversa continua no protocolo WebSocket, que não é HTTP.

#### Detalhamento

- Solicitação do navegador:

  > Exemplo:
  >
  > `new WebSocket("wss://exemplo.com.br/chat");`:

      GET /chat
      Host: exemplo.com.br
      Origin: https://exemplo.com.br
      Connection: Upgrade
      Upgrade: websocket
      Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
      Sec-WebSocket-Version: 13

  Cabeçalhos:

  - `Origin`

    > A `origem` da página do cliente.
    >
    > - O WebSocket é de `cross-origin` por natureza.
    >
    > - Não há cabeçalhos especiais ou outras limitações.
    >
    > - Os servidores antigos são incapazes de lidar com o WebSocket de qualquer maneira, portanto, não há problemas de combatibilidade.
    >
    > - O cabeçalho `Origin` é importante, pois permite que o servidor decida se deve ou não comunicar-se em WebSocket com o site de origem.

  - `Connection: Upgrade`

    > Sinaliza que o cliente gostaria de _alterar o protocolo_.

  - `Upgrade: websocket`

    > O protocolo solicitado é "websocket".

  - `Sec-WebSocket-Key`

    > Uma chave gerada aleatoriamente pelo navegador p/ _segurança_.

  - `Sec-WebSocket-Version`

    > _Versão_ do protocolo WebSocket. A atual é 13.

- Resposta do servidor:

  > Se o servidor concordar em mudar p/ WebSocket, ele deve enviar o código de resposta 101:

      101 Switching Protocols
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=

  - Aqui, `Sec-WebSocket-Accept` é o `Sec-WebSocket-Key` _recodificado_ usando um altoritmo especial. O navegador usa p/ garantir que a _resposta corresponda à solicitação_.

  - Posteriormente, os dados são transferidos usando o protocolo WebSocket.

### Dados WebSocket

- > A comunicação WebSocket consiste em _"frames"_ que podem ser enviados de ambos os lados.

- Tipos de frame WebSocket:

  - Frames de **texto**
    > Contêm dados de texto que as partes enviam entre si.
  - Frames de **dados binários**
    > Contêm dados binários que as partes enviam entre si.
  - Frames de **ping/pong**
    > São usados p/ verificar a conexão, enviados pelo servidor. O navegador responde-os automaticamente.
  - Frame de **conexão fechada**
  - E alguns outros _frames de serviços_...

- **Observações:**

  - > No navegador, nos preocupamos apenas com frames de _texto ou binários_.
    >
    > - O webSocket `.send()` pode enviar ambos os tipos.

  - > Os dados _textuais sempre vêm como string_.

  - > Já p/ receber dados _binários_, podemos escolher entre os formatos _Blob e ArrayBuffer_.

  ```js
  socket.bufferType = 'arraybuffer';
  socket.onmessage = (event) => {
    // event.data é uma string ou arraybuffer (se binário)
  };
  ```

### Encerramento da Conexão

#### Requisição de fechamento

- > Normalmente, quando uma parte deseja fechar a conexão, ela envia um "frame de fechamento de conexão" com um _código numérico_ e um _motivo textual_.

- > O navegador e o servidor têm _direitos iguais_.

- O método é:

  ```js
  socket.close([código], [razão]);
  ```

#### Resposta p/ fechamento

- > Em seguida, a outra parte no gerenciamento do evento close pode obter o código e o motivo. Por exemplo:

  ```js
  // um lado:
  socket.close(1000, 'Tarefa concluída');

  // outro lado:
  socket.onclose = (event) => {
    event.code === 1000;
    event.reason === 'Tarefa concluída';
    // event.wasClean === true (fechamento limpo)
  };
  ```

- **Código de fechamento**

  > O código de fechamento não é um número qualquer, mas um _especial do WebSocket_.

  - Principais:

    - `1000`
      > O _padrão_. Fechamento normal.
    - `1006`
      > Indica que a _conexão foi interrompida_ (sem frame de fechamento). Não se pode definir esse código manualmente.

  - Outros código:

    - `1001`
      > O servidor está sendo desligado ou um navegador saiu da página.
    - `1009`
      > A mensagem é muito grande p/ processar.
    - `1011`
      > Erro inesperado do servidor.

#### Estado da conexão

- > Para obter o estado da conexão, há também a propriedade `socket.readyState`, com valores:

  - 0 - CONNECTING
    > A conexão ainda não foi estabelecida.
  - 1 - OPEN
    > Comunicando.
  - 2 - CLOSING
    > A conexão está sendo fechada.
  - 3 - CLOSED
    > A conexão está fechada.
